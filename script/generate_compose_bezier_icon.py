import os
from pathlib import Path
from svg.path import parse_path, Arc, CubicBezier, Line, Move, Close
from xml.dom.minidom import parse

VECTOR_XML_INPUT_DIR = 'bezier/src/main/res/drawable'
VECTOR_CODE_OUTPUT_DIR = 'bezier/src/main/java/io/channel/bezier/compose/icon'

CODE_TEMPLATE = """@file:Suppress("ObjectPropertyName", "UnusedReceiverParameter")

// Auto-generated by script/generate_compose_bezier_icon.py

package io.channel.bezier.compose.icon

import androidx.compose.foundation.layout.size
import androidx.compose.material3.Icon
import androidx.compose.runtime.Composable
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.*
import androidx.compose.ui.graphics.vector.ImageVector
import androidx.compose.ui.graphics.vector.path
import androidx.compose.ui.tooling.preview.Preview
import androidx.compose.ui.unit.dp
import io.channel.bezier.compose.BezierIcon

val BezierIcon.{icon_name}: ImageVector
    get() {{
        return {temp_var} ?: ImageVector.Builder(
                name = "{icon_name}",
                defaultWidth = 24.dp,
                defaultHeight = 24.dp,
                viewportWidth = 24f,
                viewportHeight = 24f,
        ).apply {{
{builder}
        }}.build().also {{
            {temp_var} = it
        }}
    }}

private var {temp_var}: ImageVector? = null

@Preview(showBackground = true)
@Composable
private fun {icon_name}IconPreview() {{
    Icon(
            modifier = Modifier.size(128.dp),
            imageVector = BezierIcon.{icon_name},
            contentDescription = null,
    )
}}
"""


def project_rel_path_to_abs_path(path: str) -> str:
    return os.path.join(Path(__file__).parents[1], path)


def kotlin_bool(v: bool) -> str:
    if v:
        return 'true'
    else:
        return 'false'


def compose_color(color: str | None, alpha: float = -1) -> str | None:
    if color is None or color == '':
        return None

    if color[0] != '#':
        raise ValueError('color should start with #')

    if len(color) == 7:  # RGB
        if alpha == -1:
            alpha = 1
        return 'Color(0x{}{})'.format(format(int(alpha * 255), 'X'), color[1:].upper())
    elif len(color) == 9:  # ARGB
        return 'Color(0x{})'.format(color[1:].upper())
    else:
        raise ValueError('invalid color value: {}'.format(color))


def transform_xml_into_vector_code(xml_path: str, icon_accessor_name: str, kt_write_path: str):
    class PathInfo:
        def __init__(self, fill_type, fill_color, fill_alpha, stroke_color, stroke_alpha):
            self.fill_type = fill_type
            self.fill_color = fill_color
            self.fill_alpha = fill_alpha
            self.stroke_color = stroke_color
            self.stroke_alpha = stroke_alpha

        def __hash__(self):
            return hash((self.fill_type, self.fill_color, self.fill_alpha, self.stroke_color, self.stroke_alpha))

        def __eq__(self, other):
            return isinstance(other, PathInfo) and \
                self.fill_type == other.fill_type \
                and self.fill_color == other.fill_color \
                and self.fill_alpha == other.fill_alpha \
                and self.stroke_color == other.stroke_color \
                and self.stroke_alpha == other.stroke_alpha

    with open(xml_path, 'r') as f:
        document = parse(f)

    paths = {}

    for element in document.getElementsByTagName('path'):
        for path in parse_path(element.getAttribute('android:pathData')):
            path_fill_type = element.getAttribute('android:fillType') or 'nonZero'
            path_fill_color = element.getAttribute('android:fillColor')
            path_fill_alpha = element.getAttribute('android:fillAlpha') or 1.0
            path_stroke_color = element.getAttribute('android:strokeColor')
            path_stroke_alpha = element.getAttribute('android:strokeAlpha')

            code_lines = paths.get(PathInfo(
                fill_type=path_fill_type,
                fill_color=path_fill_color,
                fill_alpha=path_fill_alpha,
                stroke_color=path_stroke_color,
                stroke_alpha=path_stroke_alpha
            ), [])

            if isinstance(path, CubicBezier):
                code_lines.append('curveTo({}f, {}f, {}f, {}f, {}f, {}f)'.format(
                    path.control1.real, path.control1.imag, path.control2.real,
                    path.control2.imag, path.end.real, path.end.imag
                ))
            elif isinstance(path, Line):
                code_lines.append('lineTo({}f, {}f)'.format(path.end.real, path.end.imag))
            elif isinstance(path, Move):
                code_lines.append('moveTo({}f, {}f)'.format(path.end.real, path.end.imag))
            elif isinstance(path, Close):
                code_lines.append('close()')
            elif isinstance(path, Arc):
                code_lines.append('arcTo({}f, {}f, {}f, isMoreThanHalf = {}, isPositiveArc = {}, {}f, {}f)'
                                  .format(path.radius.real, path.radius.imag, path.theta,
                                          kotlin_bool(path.arc), kotlin_bool(path.sweep),
                                          path.end.real, path.end.imag))
            else:
                raise TypeError('This script does not support this type of SVG path element:\n    ' + str(path))

            paths[PathInfo(
                fill_type=path_fill_type,
                fill_color=path_fill_color,
                fill_alpha=path_fill_alpha,
                stroke_color=path_stroke_color,
                stroke_alpha=path_stroke_alpha
            )] = code_lines

    def path_entry_to_code(entry):
        path_info = entry[0]
        lines = entry[1]

        path_builder_code = '\n'.join(' ' * 16 + line for line in lines)

        path_arguments = {
            'fill': 'SolidColor({})'.format(compose_color(path_info.fill_color, float(path_info.fill_alpha)))
                    or 'SolidColor(Color.White)',
            'strokeLineWidth': '1f',
        }

        if path_info.stroke_color != '':
            path_arguments['stroke'] = compose_color(path_info.stroke_color, path_info.stroke_alpha or -1)
        else:
            if path_info.stroke_alpha != '':
                path_arguments['strokeAlpha'] = '{}f'.format(path_info.stroke_alpha)

        if path_info.fill_type == 'evenOdd':
            path_arguments['pathFillType'] = 'PathFillType.EvenOdd'

        return ' ' * 12 + 'path(\n' + \
            ''.join(
                list(map(
                    lambda arg_entry: ' ' * 20 + arg_entry[0] + ' = ' + arg_entry[1] + ',\n',
                    path_arguments.items()))
            ) +\
            ' ' * 12 + ') {\n' + path_builder_code + '\n' + ' ' * 12 + '}'

    # noinspection PyTypeChecker
    actual_builder_code = '\n\n'.join(list(map(path_entry_to_code, paths.items())))

    with open(kt_write_path, 'w') as f:
        f.write(CODE_TEMPLATE.format(
            icon_name=icon_accessor_name,
            temp_var='_' + icon_accessor_name[0].lower() + icon_accessor_name[1:],
            builder=actual_builder_code
        ))


def xml_filename_to_icon_name(snake_case: str) -> str:
    return ''.join(x.title() for x in snake_case.split('_')[1:])


for root, dirs, files in os.walk(project_rel_path_to_abs_path(VECTOR_XML_INPUT_DIR)):
    for file in files:
        filename, extension = os.path.splitext(file)

        if filename.startswith('icon_') and extension == '.xml':
            icon_name = xml_filename_to_icon_name(filename)
            write_path = os.path.join(project_rel_path_to_abs_path(VECTOR_CODE_OUTPUT_DIR), icon_name + '.kt')

            transform_xml_into_vector_code(
                xml_path=os.path.join(root, file),
                icon_accessor_name=icon_name,
                kt_write_path=write_path
            )
